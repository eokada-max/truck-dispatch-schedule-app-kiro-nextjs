# Implementation Plan - Phase 3: インタラクティブカレンダー機能

## Phase 1: ドラッグ&ドロップ基本機能 ✅ 完了

- [x] 1. DraggableScheduleCardコンポーネントの作成
- [x] 1.1 基本的なドラッグ機能を実装する
  - `components/schedules/DraggableScheduleCard.tsx`を作成する
  - @dnd-kitライブラリを使用する
  - ドラッグ中の視覚的フィードバック（opacity: 0.5）を実装する
  - _Requirements: 1.1, 1.2_

- [x] 1.2 ドラッグデータの管理を実装する
  - useDraggableフックでスケジュール情報を設定する
  - ドラッグ開始時のコールバックを実装する
  - _Requirements: 1.1_

- [x] 2. TimelineCalendarにドロップ機能を追加
- [x] 2.1 ドロップ可能エリアを実装する
  - 各タイムスロットにuseDroppableを追加する
  - ドラッグオーバー時のハイライト表示を実装する
  - _Requirements: 1.2, 1.3_

- [x] 2.2 ドロップ処理を実装する
  - DndContextでドラッグイベントを管理する
  - マウス位置から日付と時間を計算する（15分単位スナップ）
  - ドロップ時にスケジュールの日付と時間を更新する
  - 無効なドロップ位置の処理を実装する
  - _Requirements: 1.3, 1.4_

- [x] 3. スケジュール更新ロジックの実装
- [x] 3.1 データベース更新を実装する
  - ドロップ時にSupabaseを更新する
  - 楽観的UI更新を実装する
  - エラーハンドリングを実装する
  - _Requirements: 1.3, 1.5_

- [x] 4. 視覚的フィードバックの実装
- [x] 4.1 ドラッグ中のプレビューを実装する
  - ドラッグ中のスケジュールカードのスタイルを調整する
  - DragOverlayでドロップターゲットインジケーターを表示する
  - _Requirements: 4.1, 4.2_

- [x] 4.2 ドロップ位置のハイライトを実装する
  - 有効なドロップ位置をハイライトする
  - pointerWithin衝突検出アルゴリズムを使用する
  - _Requirements: 4.3, 4.4_

## Phase 2: 時間範囲選択機能

- [x] 5. TimelineCalendarに時間範囲選択を追加






- [x] 5.1 マウスイベントハンドラーを実装する

  - onMouseDown、onMouseMove、onMouseUpイベントを追加する
  - スケジュールカード上でのクリックを無視する
  - useStateで選択状態を管理する
  - _Requirements: 2.1, 2.5_

- [x] 5.2 選択範囲の表示を実装する

  - 選択中の矩形を表示する（青い半透明のdiv）
  - リアルタイムで選択範囲を更新する
  - CSSで位置とサイズを計算する
  - _Requirements: 2.1, 2.2_


- [x] 5.3 時間計算ロジックを実装する
  - マウス位置（clientY）から時間を計算する
  - 15分単位にスナップする
  - 最小選択時間（15分）をチェックする
  - _Requirements: 2.4_

- [x] 6. フォーム連携の実装



- [ ] 6.1 選択完了時の処理を実装する
  - 選択範囲から日付と時間を抽出する
  - スケジュール作成フォームを開く
  - 日付と時間を自動入力する
  - _Requirements: 2.3, 2.4_


- [ ] 6.2 SchedulesClientの更新
  - 時間範囲選択のコールバックを実装する
  - フォームに選択した日付と時間を渡す
  - _Requirements: 2.3_

## Phase 3: リサイズ機能

- [x] 7. DraggableScheduleCardにリサイズ機能を追加




- [x] 7.1 リサイズハンドルのUIを実装する

  - 上端と下端に8pxの透明なハンドル領域を追加する
  - ホバー時にカーソルを変更する（cursor: ns-resize）
  - CSSで絶対配置する
  - _Requirements: 3.1_


- [x] 7.2 リサイズロジックを実装する

  - onMouseDownでリサイズモード開始
  - onMouseMoveで時間を計算する（15分単位）
  - onMouseUpでリサイズ完了
  - リサイズとドラッグの競合を防ぐ（e.stopPropagation）
  - _Requirements: 3.2, 3.3, 3.4_

- [x] 7.3 リサイズ完了時の処理を実装する

  - リサイズ完了時にSupabaseを更新する
  - 楽観的UI更新を実装する
  - _Requirements: 3.5_

## Phase 4: 競合検出とUndo機能

- [x] 10. 競合検出機能の実装



- [x] 10.1 競合チェックロジックを作成する


  - `lib/utils/conflictDetection.ts`を作成する
  - 時間範囲の重複を検出する関数を実装する
  - ドライバーごとの競合をチェックする
  - _Requirements: 5.1, 5.3_

- [x] 10.2 競合警告UIを実装する


  - 競合検出時に警告ダイアログを表示する
  - 競合するスケジュールをハイライトする
  - 確認後に続行できるようにする
  - _Requirements: 5.1, 5.2, 5.3_

- [x] 10.3 リアルタイム競合チェックを実装する


  - ドラッグ中に競合をチェックする
  - 競合がある場合は視覚的に表示する
  - _Requirements: 5.4_

- [ ] 11. Undo機能の実装
- [ ] 11.1 操作履歴の管理を実装する
  - `lib/utils/undoManager.ts`を作成する
  - 最後の10操作を履歴に保存する
  - _Requirements: 7.2, 7.4_

- [ ] 11.2 Undo UIを実装する
  - 成功メッセージに「元に戻す」ボタンを追加する
  - Escapeキーでドラッグをキャンセルする
  - 5秒以内にUndoできるようにする
  - _Requirements: 7.1, 7.2, 7.3_

## Phase 5: モバイル対応とアクセシビリティ

- [ ] 12. タッチイベントのサポート
- [ ] 12.1 タッチイベントハンドラーを実装する
  - タッチスタート、タッチムーブ、タッチエンドを処理する
  - 長押しでドラッグモードを開始する
  - 最小ドラッグ距離を設定する（誤操作防止）
  - _Requirements: 6.1, 6.2, 6.4_

- [ ] 12.2 モバイルUIの最適化
  - タッチフレンドリーなリサイズハンドルを実装する
  - ハプティックフィードバックを追加する
  - _Requirements: 6.3, 6.5_

- [ ] 13. キーボード操作の実装
- [ ] 13.1 キーボードナビゲーションを実装する
  - Enterキーで移動モードを開始する
  - 矢印キーでスケジュールを移動する
  - Enterキーで確定、Escapeキーでキャンセルする
  - _Requirements: 9.1, 9.2, 9.3, 9.4_

- [ ] 13.2 スクリーンリーダー対応を実装する
  - aria-label属性を追加する
  - ライブリージョンで変更を通知する
  - _Requirements: 9.5_

## Phase 6: パフォーマンス最適化

- [ ] 14. パフォーマンス最適化
- [ ] 14.1 レンダリング最適化を実装する
  - React.memoでコンポーネントをメモ化する
  - useMemoで計算をキャッシュする
  - useCallbackでコールバックをメモ化する
  - _Requirements: 8.1, 8.5_

- [ ] 14.2 イベント処理の最適化
  - ドラッグ中の位置計算をスロットルする（50ms）
  - デバウンスでデータベース更新を制限する
  - _Requirements: 8.2, 8.5_

- [ ] 14.3 楽観的UI更新の実装
  - データベース更新前にUIを即座に更新する
  - エラー時にロールバックする
  - _Requirements: 8.3, 10.2_

## Phase 7: データ整合性とエラーハンドリング

- [ ] 15. データ整合性の確保
- [ ] 15.1 バリデーションを実装する
  - ドロップ前に日付と時間を検証する
  - 無効なデータを拒否する
  - _Requirements: 10.1_

- [ ] 15.2 エラーハンドリングを実装する
  - データベース更新失敗時にロールバックする
  - エラーメッセージを表示する
  - _Requirements: 10.2_

- [ ] 15.3 同時編集の防止
  - ドラッグ中にスケジュールをロックする
  - 更新後にタイムラインをリフレッシュする
  - _Requirements: 10.3, 10.4_

- [ ]* 15.4 監査ログの実装
  - ドラッグ&ドロップ操作をログに記録する
  - _Requirements: 10.5_

## Phase 8: テストとドキュメント

- [ ]* 16. ユニットテストの作成
  - DraggableScheduleCardのテストを作成する
  - TimeSlotSelectorのテストを作成する
  - ResizeHandlesのテストを作成する
  - 競合検出ロジックのテストを作成する
  - _Requirements: All_

- [ ]* 17. 統合テストの作成
  - ドラッグ&ドロップの統合テストを作成する
  - 時間範囲選択の統合テストを作成する
  - リサイズの統合テストを作成する
  - _Requirements: All_

- [ ]* 18. ドキュメントの作成
  - ユーザーガイドを作成する
  - 開発者向けドキュメントを作成する
  - _Requirements: All_

## 今後の機能拡張（Phase 4以降）

- [ ] 複数スケジュールの一括移動
- [ ] スケジュールのコピー&ペースト
- [ ] 自動スケジューリング（最適な時間を提案）
- [ ] スケジュールテンプレート機能
- [ ] 繰り返しスケジュールの作成


## Phase 9: パフォーマンス最適化

- [x] 19. Reactコンポーネントの最適化



- [x] 19.1 メモ化の実装


  - React.memoでScheduleCard、DraggableScheduleCardをメモ化する
  - useCallbackでイベントハンドラーをメモ化する
  - useMemoで重い計算をキャッシュする
  - _パフォーマンス: 不要な再レンダリングを削減_


- [x] 19.2 コンポーネント分割の最適化





  - TimelineCalendarを小さなコンポーネントに分割する





  - DroppableColumnを最適化する

  - _パフォーマンス: レンダリング範囲を最小化_



- [x] 20. データフェッチの最適化





- [x] 20.1 Supabaseクエリの最適化


  - 必要なフィールドのみを取得する（SELECT *を避ける）
  - JOINを使ってクエリ数を削減する
  - インデックスを活用したクエリを作成する
  - _パフォーマンス: データベースアクセスを高速化_

- [x] 20.2 キャッシング戦略の実装


  - SWR（stale-while-revalidate）パターンを実装する
  - クライアント側でデータをキャッシュする
  - _パフォーマンス: ネットワークリクエストを削減_

- [ ] 21. レンダリングパフォーマンスの最適化
- [x] 21.1 デバウンス/スロットルの実装





  - ドラッグ中の位置計算をスロットルする（16ms）
  - 検索入力をデバウンスする（300ms）
  - _パフォーマンス: 過剰な処理を防ぐ_

- [x] 21.2 遅延ロードの拡張




  - 画面外のスケジュールを遅延レンダリングする
  - Intersection Observerを使用する
  - _パフォーマンス: 初期レンダリングを高速化_

- [x] 22. バンドルサイズの最適化







- [x] 22.1 コード分割の改善



  - 動的インポートを増やす
  - ルートごとにコードを分割する
  - _パフォーマンス: 初期ロード時間を短縮_

- [x] 22.2 依存関係の最適化


  - 未使用のライブラリを削除する
  - tree-shakingを確認する
  - バンドルアナライザーで分析する
  - _パフォーマンス: バンドルサイズを削減_

- [x] 23. 画像とフォントの最適化





- [x] 23.1 next/imageの活用


  - 画像を最適化する（WebP、AVIF）
  - レスポンシブ画像を実装する
  - _パフォーマンス: 画像読み込みを高速化_

- [x] 23.2 フォントの最適化


  - フォントのサブセット化
  - font-displayの最適化
  - _パフォーマンス: テキストレンダリングを改善_

- [ ] 24. パフォーマンス計測と監視
- [ ] 24.1 パフォーマンス計測の実装
  - Lighthouseでスコアを計測する
  - Core Web Vitalsを監視する（LCP、FID、CLS）
  - _パフォーマンス: 改善効果を定量化_

- [ ] 24.2 パフォーマンス監視の設定
  - Vercel Analyticsを設定する
  - パフォーマンスダッシュボードを作成する
  - _パフォーマンス: 継続的な監視_
